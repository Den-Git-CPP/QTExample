//
//7.2.Массив - 
//
это экземпляр контейнерного класса array(), моделирующий статический массив.
Массив - это последовательность элементов, имеющая постоянный размер.Таким образом, невозможно ни добавить, ни удалить элементы, чтобы изменить размер массива. Можно лишь заменять элементы массива.

#include <array>
//
//7.2.1.Возможности массивов
//Инициализация.Необходимо предусмотреть пустой инициализатор нулем :
//

std::array<int, 4> х = {}; // ОК: все элементы массива х равны 0 (int())
std::array<int, 5> coll = { 42, 377, 611, 21, 44 };
std::array<int, 10>с2 = { 42 }; // один элемент со значением 42,за которым следуют 9 элементов //со значением 0
//
//Таблица 7.4.Конструкторы и деструктор класса array()
//
array<Elem, N> с Конструктор по умолчанию; создает массив с элементами, инициализированными по умолчанию

array<Elem, N> с(с2)
array<Elem, N> с = с2
/**
Копирующий конструктор; создает копию другого массива того же типа(все элементы копируются)
*/
array<Elem, N> с(rv)
array<Elem, N> с = rv
Перемещающий конструктор; создает новый массив, перемещая(или копируя) массива п > (по стандарту С++11)

array<Elem, N> с = initlist
Создает массив, инициализированный элементами из списка инициализации

c.~array()	Уничтожает все элементы
//
//Немодифицирующие операции
//
с.empty()	/*Возвращает признак того, что контейнер пуст(эквивалент size() == 0, но может работать быстрее)*/
с.size()	/*Возвращает текущее количество элементов*/
с.maxsize() Возвращает максимально возможное количество элементов
cl == с2	Проверка того, что массив cl равен массиву с2(выполняет оператор == для всех элементов)
cl != с2	Проверка того, что массив cl не равен массиву с2(эквивалент !(с1 == с2))
cl < с2		Проверка того, что массив cl меньше массива с2
cl > с2		Проверка того, что массив cl больше массива с2(эквивалент с2 < с1)
cl <= с2	Проверка того, что массив cl меньше или равен массиву с2(эквивалент!(с2 < с1))
cl >= с2	Проверка того, что массив cl больше или равен массиву с2(эквивалент!(с1 < с2))
//
//Присваивание
//
с = с2		Присваивает все элементы массива с2 массиву с
с = rv		Перемещает все элементы массива rv в массив с(по стандарту С++11)
с.fill(val) Присваивает значение val каждому элементу массива с
cl.swap(c2), swap(c1, c2) Обменивает элементы массивов с1 и с2
///
//Доступ к элементам
//	
c[idx]   	Возвращает элемент с индексом кЬс(проверка выхода за пределы допустимого диапазона не выполняется)
с.at(idx) 	Возвращает элемент с индексом idx(при выходе за пределы допустимого диапазона генерирует исключение out_ofrange)
с.front() 	Возвращает первый элемент(проверка существования первого элемента не выполняется)
с.back() 	Возвращает последний элемент(проверка существования последнего элемента не выполняется)
//
//Функции для итераторов
//Таблица 7.8.Операции над итераторами класса arrayo


с.begin() 	/*Возвращает итератор произвольного доступа, установленный на первый элемент*/
с.end() 	Возвращает итератор произвольного доступа, установленный на позицию, следующую за последним элементом
c.cbegin() 	Возвращает константный итератор произвольного доступа, установленный на первый элемент(по стандарту С++11)
c.cend()	Возвращает константный итератор произвольного доступа, установленный на позицию, следующую за последним элементом(начиная со стандарта С++11)
с.rbegin()	Возвращает обратный итератор, установленный на первый элемент в обратном обходе
с.rend()	Возвращает обратный итератор, установленный на позицию, следующую за последним элементом в обратном обходе
c.crbegin()	Возвращает константный обратный итератор, установленный на первый элемент в обратном обходе(по стандарту С++11)
с.crend()	Возвращает константный обратный итератор, установленный на позицию, следующую за последним элементом в обратном обходе(по стандарту С++11)
/*
Пример использования
*/
#include <iostream>
#include <array>
#include <string>

int main()
{
    std::array<std::string, 5> names = { "Tom", "Alice", "Kate", "Bob", "Sam" };
    std::string third = names.at(2);    // Kate
   
    std::string first = names.front();  // Tom
    std::string last = names.back();    // Sam

    std::cout << third << "\n" << first << "\n" << last << std::endl;

    names.fill("Tim");  // names = { "Tim", "Tim", "Tim", "Tim", "Tim" }
    for (int i = 0; i < names.size(); i++)
    {
        std::cout << names[i] << std::endl;
    }
    return 0;
}
